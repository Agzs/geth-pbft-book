## 编译遇到的问题及解决方法

### 1、gorocksdb包问题
通过go get 获取最新的gorocsdb，遇到
```go
file: 'file:///home/zhiguo/go/src/github.com/tecbot/gorocksdb/db.go'
severity: 'Error'
message: '# github.com/tecbot/gorocksdb
could not determine kind of name for C.rocksdb_cache_get_pinned_usage
could not determine kind of name for C.rocksdb_cache_get_usage
'
at: '1,1'
source: ''
```
查看[tecbot/gorocksdb](https://github.com/tecbot/gorocksdb)说明文档发现，需要在系统上先`build RocksDB v5.5+`.

根据[facebook/rocksdb](https://github.com/facebook/rocksdb/blob/master/INSTALL.md)安装文档，参考[安装rocksdb博客](http://www.cnblogs.com/shuren/p/3981744.html)，发现仍未解决问题。

最终临时解决方法：比较最新的`tecbot/gorocksdb`(有49个文件)和`fabric/vendor/github/tecbot/gorocksdb`(有29个文件)，尝试在gopath/src/github.com目录下，删除最新的`tecbot/gorocksdb`，然后复制粘贴`fabric/vendor/github`目录下tecbot/gorocksdb`，
最终项目可进行编译。

在编译的过程中又遇到如下错误：
```go
github.com/tecbot/gorocksdb
github.com/yeongchingtarn/geth-pbft/core/db
github.com/yeongchingtarn/geth-pbft/consensus/pbft
github.com/yeongchingtarn/geth-pbft/eth
github.com/yeongchingtarn/geth-pbft/les
github.com/yeongchingtarn/geth-pbft/ethstats
github.com/yeongchingtarn/geth-pbft/contracts/release
github.com/yeongchingtarn/geth-pbft/cmd/utils
github.com/yeongchingtarn/geth-pbft/cmd/faucet
github.com/yeongchingtarn/geth-pbft/cmd/bootnode
# github.com/yeongchingtarn/geth-pbft/cmd/faucet
2017/10/27 09:18:08 duplicate symbol _cgoexp_4c7b26b16232_gorocksdb_compactionfilter_filter (types 1 and 1) in github.com/hyperledger/fabric/vendor/github.com/tecbot/gorocksdb and /home/ethtest/go/pkg/linux_amd64/github.com/tecbot/gorocksdb.a(_go_.o)
github.com/yeongchingtarn/geth-pbft/cmd/evm
# github.com/yeongchingtarn/geth-pbft/cmd/bootnode
2017/10/27 09:18:08 duplicate symbol _cgoexp_4c7b26b16232_gorocksdb_compactionfilter_filter (types 1 and 1) in github.com/hyperledger/fabric/vendor/github.com/tecbot/gorocksdb and /home/ethtest/go/pkg/linux_amd64/github.com/tecbot/gorocksdb.a(_go_.o)
github.com/yeongchingtarn/geth-pbft/cmd/geth
# github.com/yeongchingtarn/geth-pbft/cmd/evm
2017/10/27 09:18:09 duplicate symbol _cgoexp_4c7b26b16232_gorocksdb_compactionfilter_filter (types 1 and 1) in github.com/hyperledger/fabric/vendor/github.com/tecbot/gorocksdb and /home/ethtest/go/pkg/linux_amd64/github.com/tecbot/gorocksdb.a(_go_.o)
# github.com/yeongchingtarn/geth-pbft/cmd/geth
2017/10/27 09:18:09 duplicate symbol _cgoexp_4c7b26b16232_gorocksdb_compactionfilter_filter (types 1 and 1) in github.com/hyperledger/fabric/vendor/github.com/tecbot/gorocksdb and /home/ethtest/go/pkg/linux_amd64/github.com/tecbot/gorocksdb.a(_go_.o)
```
发现某些类型重复

临时解决方法：将`fabric/vendor/tecbot/gorocksdb`删除，项目可编译

### 2、可执行程序
在`geth-pbft`目录下，终端运行`go install ./cmd/geth`只生成geth可执行文件，而通过`go install ./...`编译所有的`geth-pbft`文件，生成七个可执行文件：`abigen`、`bootnode`、`evm`、`faucet`、`geth`、`puppeth`、`rlpdump`，都位于`gopath/bin`目录下，其中会用到的有`geth`和`puppeth`

但是，系统存在之前安装的`geth`和`puppeth`，位于usr/bin目录下，将其通过`sudo mv XXX /home/ethtest/gethexe`移动到其他目录下。如果不进行此操作，在终端运行的`geth`和`puppeth`都是之前安装的版本，并非本次编译生成的可执行文件。

若要测试编译生成的`geth`和`puppeth`，可在`gopath/bin`目录下将可执行文件重命名，比如`geth2`、`puppeth2`，然后运行。

## 运行遇到的问题

虽然编译通过，生成了可执行文件，但是运行过程中依然会产生许多问题。

解决方法：根据命令行终端提示，找到源码所在位置，进行修改，保存，重新编译。

比如，下面这几个错误：
### 1 `panic: runtime error: invalid memory address or nil pointer dereference`
* 例一、赋值操作
```go
    pb.pbft.helper.manager = pb.manager //=> add helper.manager --Agzs		
    configV := loadConfig()                           //=>replace configV in New()  prams. --Agzs

    pb.pbft = newPbftCore(id, configV, etf, com, fin)
```
发现pb.pbft在未被初始化的情况下进行了赋值，导致了空指针错误。解决方法：将赋值语句移到pbft初始化下方。

例二、openChainDB.DB.Get()
在运行`geth --datadir ./data --networkid 55661  --port 2000 console`指令时，提示错误如下：
```go
github.com/tecbot/gorocksdb.(*DB).GetCF(0x0, 0xc42000e190, 0x0, 0xc4202edd50, 0xe, 0x10, 0x0, 0x0, 0x0)
	/home/ethtest/go/src/github.com/tecbot/gorocksdb/db.go:258 +0xb6
github.com/yeongchingtarn/geth-pbft/core/db.(*OpenchainDB).Get(0xc4203bf200, 0x0, 0xc4202edd50, 0xe, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0)
	/home/ethtest/go/src/github.com/yeongchingtarn/geth-pbft/core/db/db.go:255 +0xf0
github.com/yeongchingtarn/geth-pbft/consensus/pbft.(*databaseHelper).ReadState(0xc420404f38, 0x1045a50, 0x4, 0x439096, 0x0, 0x0, 0xc4204ad990, 0x4a8edc)
	/home/ethtest/go/src/github.com/yeongchingtarn/geth-pbft/consensus/pbft/persist.go:49 +0xc3
```
根据提示，找到如下源码：
```go
// ReadState retrieves a value to a key
func (h *databaseHelper) ReadState(key string) ([]byte, error) {
	db := db.GetDBHandle()
	return db.Get(db.PersistCF, []byte("consensus."+key))
}
func create() *OpenchainDB {
	return &OpenchainDB{}
}
func (openchainDB *OpenchainDB) Get(cfHandler *gorocksdb.ColumnFamilyHandle, key []byte) ([]byte, error) {
	...
	slice, err := openchainDB.DB.GetCF(opt, cfHandler, key)
	...
}
```
发现`openchainDB`并没有初始化,导致`openchainDB.DB`为空指针
解决方法：通过研究源码发现，openchainDB在db.go的Start()函数中，通过层层调用进行了初始化，所以在geth-pbft/eth/backend.go的New()中添加了db.Start()，vscode可能会自动添加import "github.com/hyperledger/fabric/core/db"，我们要改成"github.com/yeongchingtarn/geth-pbft/core/db"，保存，重新编译，又遇到错误😭，`panic: DB path not specified in configuration file. Please check that property 'peer.fileSystemPath' is set`。

### 2 `panic: DB path not specified in configuration file. Please check that property 'peer.fileSystemPath' is set`
根据提示，找到源码：
```go
func getDBPath() string {
	dbPath := viper.GetString("peer.fileSystemPath")
	if dbPath == "" {
		panic("DB path not specified in configuration file. Please check that property 'peer.fileSystemPath' is set")
	}
	if !strings.HasSuffix(dbPath, "/") {
		dbPath = dbPath + "/"
	}
	return dbPath + "db"
}
```
fabric/peer/core.yaml文件中有关于`peer.fileSystemPath`的定义：
```go
###############################################################################
#
#    Peer section
#
###############################################################################
peer:
    ...
    # Path on the file system where peer will store data
    fileSystemPath: /var/hyperledger/production
    # rocksdb configurations
    db:
        maxLogFileSize: 10485760
        keepLogFileNum: 10
        logLevel: "warn"

    profile:
        enabled:     false
        listenAddress: 0.0.0.0:6060

```
猜想可能是viper路径问题，解决方法如下：
* 1) geth-pbft/node/core.yaml

参考fabric/peer/core.yaml文件，添加.yaml文件，如下：
```go
peer:
    # Path on the file system where peer will store data
    fileSystemPath: /home/ethtest/hyperledgerRocksDB/data # //=> should be changed for different OS. --Agzs
    # rocksdb configurations
    db:
        maxLogFileSize: 10485760
        keepLogFileNum: 10
        logLevel: "warn"

    profile:
        enabled:     false
        listenAddress: 0.0.0.0:6060
```
注：由于无法在`computer`目录下创建其他文件夹，所以采取在`home/ethtest`目录下保存`rocksdb`文件，`fileSystemPath`需根据不同的系统账户进行设置，我的账户为`ethtest`。

* 2) 修改geth-pbft中所有的rocksdb包的导入路径

将所有的`"github.com/hyperledger/fabric/core/db"`改为`"github.com/yeongchingtarn/geth-pbft/core/db"`

* 3) geth-pbft/cmd/geth/main.go

在该文件下的init()函数中添加viper的初始化，如下：
```go
func init() {
	//=> init viper. --Agzs
	viper.SetEnvPrefix(cmdRoot)
	viper.AutomaticEnv()
	var alternativeCfgPath = os.Getenv("PEER_CFG_PATH")
	if alternativeCfgPath != "" {
		logger.Infof("User defined config file path: %s", alternativeCfgPath)
		viper.AddConfigPath(alternativeCfgPath) // Path to look for the config file in
	} else {
		viper.AddConfigPath("./") // Path to look for the config file in
		// Path to look for the config file in based on GOPATH
		gopath := os.Getenv("GOPATH")
		for _, p := range filepath.SplitList(gopath) {
			peerpath := filepath.Join(p, "src/github.com/yeongchingtarn/geth-pbft/node")
			viper.AddConfigPath(peerpath)
		}
	}

	// Now set the configuration file.
	viper.SetConfigName(cmdRoot) // Name of config file (without extension)

	err := viper.ReadInConfig() // Find and read the config file
	if err != nil {             // Handle errors reading the config file
		panic(fmt.Errorf("Fatal error when reading %s config file: %s\n", cmdRoot, err))
	}
	...
}
```
* 4) 保存，重新编译，运行

* 运行结果

发现单一终端运行成功，但是多个终端运行提示文件上锁：
```go
ethtest@aguan-VirtualBox:~/pbft/signer2$ geth --datadir ./data --networkid 55661 --port 2003 --unlock 426f88a7fda6bdb3ef2647214e5c4107a5ead6ff console
INFO [10-30|08:58:21] Starting peer-to-peer node               instance=Geth/v1.6.7-stable/linux-amd64/go1.8
2017/10/30 08:58:21 Is db path [/home/ethtest/hyperledgerRocksDB/data/db] empty [false]
2017/10/30 08:58:21 Setting rocksdb maxLogFileSize to 10485760
2017/10/30 08:58:21 Setting rocksdb keepLogFileNum to 10
2017/10/30 08:58:21 Setting rocks db InfoLogLevel to 2
panic: Error opening DB: IO error: lock /home/ethtest/hyperledgerRocksDB/data/db/LOCK: Resource temporarily unavailable

goroutine 1 [running]:
github.com/yeongchingtarn/geth-pbft/core/db.(*OpenchainDB).open(0xc4203a1da0)
	/home/ethtest/go/src/github.com/yeongchingtarn/geth-pbft/core/db/db.go:201 +0x886
github.com/yeongchingtarn/geth-pbft/core/db.Start()
	/home/ethtest/go/src/github.com/yeongchingtarn/geth-pbft/core/db/db.go:77 +0x2d
...
```
目前有两种解决方法：
* 1）采取阿里云，部署多个终端(至少4个），进行测试。

目前设备数不足，暂时未采取。
* 2）仿照levelDB在同一终端下分文件夹保存各自DB。

打算编译生成四个geth可执行程序，编号0、1、2、3，各自使用自己的core.yaml文件，每个文件的fileSystemPath各自设置。然后进行操作。大概需要六个终端，四个用作VP，两个用作Node(进行交易)

目前正在测试第二种方法。。。。。。
### 3 乱码问题
```go
> miner.start()
INFO [10-30|11:33:48] Transaction pool price threshold updated price=18000000000
null
> INFO [10-30|11:33:48] Starting mining operation 
INFO [10-30|11:33:48] Commit new mining work                   number=1 txs=0 uncles=0 elapsed=334.103µs
�GU10/30 11:33:48 Replica 0 received a block �j�^#��4E�^�>���V9���
�GU10/30 11:33:48 Replica 0 soft starting new view timer for 2s: new block �j�^#��4E�^�>���V9���
�GU10/30 11:33:48 Replica 0 is primary, issuing pre-prepare for block �j�^#��4E�^�>���V9���
2017/10/30 11:33:48 Primary 0 broadcasting pre-prepare for view=0/seqNo=2 and digest �j�^#��4E�^�>���V�GU
2017/10/30 11:33:48 Starting timer
2017/10/30 11:33:48 Replica 0 prepare count for view=0/seqNo=2: 0
2017/10/30 11:33:48 Attempting to stop an unfired idle timer
2017/10/30 11:33:48 Stopping timer
2017/10/30 11:33:50 Event timer fired
2017/10/30 11:33:50 Timer event delivered
2017/10/30 11:33:50 Replica 0 batch main thread looping
2017/10/30 11:33:50 Replica 0 processing event
2017/10/30 11:33:50 Replica 0 view change timer expired, sending view change: new block �j�^#��4E�^�>��GU��
2017/10/30 11:33:50 Replica 0 stopping a running new view timer
2017/10/30 11:33:50 Replica 0 prepare count for view=0/seqNo=2: 0
2017/10/30 11:33:50 Attempting to stop an unfired idle timer
2017/10/30 11:33:50 Stopping timer
```
解决方法：

地址类型address，如果需要输出的话需要`%x`格式输出，例如`fmt.Sprintf("new block %x", digest)`

若在终端打印提示语句，可采用go-etheren/log包里的函数，log.Info("提示语"， "变量名1",变量名1,"变量名2",变量名2)，比如：

`log.Info("Replica is primary, issuing pre-prepare for block", "Replica(PeerID)", instance.id, "hash", common.BytesToHash(digest))`

输出的效果：

`INFO [11-03|21:57:45] Replica is primary, issuing pre-prepare for block Replica(PeerID)=0 hash=6c500d…45b211`

### 4、时间机制or广播？
```go
> miner.start()
INFO [10-30|20:26:55] Transaction pool price threshold updated price=18000000000
nullINFO [10-30|20:26:55] Starting mining operation 

> INFO [10-30|20:26:55] Commit new mining work                   number=1 txs=0 uncles=0 elapsed=111.914µs
2017/10/30 20:26:55 Replica 0 received a block ��ߒ�M�>��R��S�$KW���<p��G"��X�
2017/10/30 20:26:55 Replica 0 soft starting new view timer for 20s: new block ��ߒ�M�>��R��S�$KW���<p��G"��X�
2017/10/30 20:26:55 Replica 0 is primary, issuing pre-prepare for block ��ߒ�M�>��R��S�$KW���<p��G"��X�
2017/10/30 20:26:55 Primary 0 broadcasting pre-prepare for view=0/seqNo=5 and digest ��ߒ�M�>��R��S�$KW���<p��G"��X�
2017/10/30 20:26:55 Starting timer
2017/10/30 20:26:55 Replica 0 prepare count for view=0/seqNo=5: 0
2017/10/30 20:26:55 Attempting to stop an unfired idle timer
2017/10/30 20:26:55 Stopping timer
2017/10/30 20:27:15 Event timer fired
2017/10/30 20:27:15 Timer event delivered
2017/10/30 20:27:15 Replica 0 batch main thread looping
2017/10/30 20:27:15 Replica 0 processing event
2017/10/30 20:27:15 Replica 0 view change timer expired, sending view change: new block ��ߒ�M�>��R��S�$KW���<p��G"��X�
2017/10/30 20:27:15 Replica 0 stopping a running new view timer
2017/10/30 20:27:15 Replica 0 prepare count for view=0/seqNo=5: 0
2017/10/30 20:27:15 Attempting to stop an unfired idle timer
2017/10/30 20:27:15 Stopping timer

> miner.stop()
INFO [10-30|20:32:35] Stop PBFT algorithm! 

```

原因：由于项目从pbft/config.yaml读取数据，config.yaml中关于时间设置如下：
```go
timeout:

        # Send a pre-prepare if there are pending requests, batchsize isn't reached yet,
        # and this much time has elapsed since the current batch was formed
        batch: 1s

        # How long may a request take between reception and execution, must be greater than the batch timeout
        request: 2s

        # How long may a view change take
        viewchange: 2s

        # How long to wait for a view change quorum before resending (the same) view change
        resendviewchange: 2s

        # Interval to send "keep-alive" null requests.  Set to 0 to disable. If enabled, must be greater than request timeout
        nullrequest: 0s

        # How long may a message broadcast take.
        broadcast: 1s
```

解决方法：将上述时间扩大10倍，用于测试，**后期在进行修改**...

### 5、同一主节点终端，提示错误
```go
> miner.start()
INFO [10-30|20:32:41] Transaction pool price threshold updated price=18000000000
null
INFO [10-30|20:32:41] Starting mining operation 
> INFO [10-30|20:32:41] Commit new mining work                   number=1 txs=0 uncles=0 elapsed=100.888µs
WARN [10-30|20:32:41] Block sealing failed                     err="not primary note, cannot issue Seal"
> miner.stop()
true
```
主节点miner.stop()后重新miner.start()，提示上述错误，初步判定当前主节点的时间机制触发viewchange，而其他VP未收到viewchange，当前主节点的view变化，导致在新的view中主节点不再是当前的主节点，待解决。






### 6、pbftMessage无法广播出去

当`commChan`中产生新消息时，`protocolManager`会调用`BroadcastMsg()`，该函数如下：
```go
func (pm *ProtocolManager) BroadcastMsg(msg *types.PbftMessage) {
	
	/// TODO: May need to optimize it, only broadcast msg to peers without it. --Zhiguo
	///	peers := pm.peers.PeersWithoutTx(hash)
	//FIXME include this again: peers = peers[:int(math.Sqrt(float64(len(peers))))]
	
	//=> add PeerWithoutMsg() start. --Agzs
	hash := types.Hash(msg)
	peers := pm.peers.PeersWithoutMsg(hash)

	for _, peer := range peers {
		log.Info("peer broadcast msg", "peer", peer.id, "send msg's hash:", hash) //=>test. --Agzs
		peer.SendMsg(msg)
	}

	log.Trace("Broadcast transaction", "hash", hash, "recipients", len(pm.peers.peers)) //=> peers ->  pm.peers.peers --Agzs
}
```
该函数会对加入到p2p的每个peer调用SendMsg()，最终会调用go-ethereum/p2p中`Send(p.rw, ConsensusMsg, msg)`，通过打印数据发现
此时，并没有真正发送出去，此过程还涉及到rlp编码；Send()函数最终会在`ethereum/go-ethereum/rlp/typecache.go`中`genTypeInfo()`函数内调用`makeDecoder()`和`makeWriter()`.

```go
func makeDecoder(typ reflect.Type, tags tags) (dec decoder, err error) {
	kind := typ.Kind()
	log.Info(" makeDecoder --start--", "typeName", kind) //=>test. --Agzs
	switch {
	case typ == rawValueType:
		return decodeRawValue, nil
	case typ.Implements(decoderInterface):
		return decodeDecoder, nil
	case kind != reflect.Ptr && reflect.PtrTo(typ).Implements(decoderInterface):
		return decodeDecoderNoPtr, nil
	case typ.AssignableTo(reflect.PtrTo(bigInt)):
		return decodeBigInt, nil
	case typ.AssignableTo(bigInt):
		return decodeBigIntNoPtr, nil
	case isUint(kind):
		return decodeUint, nil
	case kind == reflect.Bool:
		return decodeBool, nil
	case kind == reflect.String:
		return decodeString, nil
	case kind == reflect.Slice || kind == reflect.Array:
		return makeListDecoder(typ, tags)
	case kind == reflect.Struct:
		return makeStructDecoder(typ)
	case kind == reflect.Ptr:
		if tags.nilOK {
			return makeOptionalPtrDecoder(typ)
		}
		return makePtrDecoder(typ)
	case kind == reflect.Interface:
		return decodeInterface, nil
	// case kind == reflect.Map: //=>TODO. --Agzs
	// 	return nil, nil
	default:
		log.Info(" makeDecoder --default--", "typeName", kind) //=>test. --Agzs
		return nil, fmt.Errorf("rlp: type %v is not RLP-serializable", typ)
	}
}
```
* 原因：

1）`msg.code`和`protoclLength`问题，学姐已解决,实际上只需要对eth63版本的长度+1就行，eth62版本长度仍然是8。后期添加新的编号时，eth63的长度需要加相应的个数。

2)由于`types.PbftMessage`所包含的成员变量存在switch分支中未定义的类型，所以将匹配default分支,最终会返回错误。

* 解决方法：

重新定义了types.PbftMessage的结构体，好像不用修该这部分结构体也可以.

在NewView中的XSet成员变量为`map[uint64]string`类型，而`makeDecoder()`的switch分支中并没有reflect.Map，如果新增加该分支的话，需要自己编写相关的decoder函数，涉及元数据，容易出错，所以现在临时将Xset由`map[uint64]string`定义为`[]*XSet`类型，涉及xset的都需要改变，由于修改内容比较多，在此不详细介绍，在[修改文件汇总11.5](https://github.com/Agzs/geth-pbft-study/wiki/%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%B1%87%E6%80%BB)中介绍。

修改本部分后，其他的signer可收到types.PbftMessage类型，msg.code也为17，但是出现解码错误问题(一）

### 7、解码错误问题(一）
```go
//位于ethereum/go-ethereum/rlp/typecache.go
func (s *Stream) Decode(val interface{}) error {
	if val == nil {
		return errDecodeIntoNil
	}
	rval := reflect.ValueOf(val)
	rtyp := rval.Type()
	if rtyp.Kind() != reflect.Ptr {
		return errNoPointer
	}
	if rval.IsNil() {
		return errDecodeIntoNil
	}

	info, err := cachedTypeInfo(rtyp.Elem(), tags{})
	if err != nil {
		return err
	}

	err = info.decoder(s, rval.Elem()) //=> consensusMsg will call decodeInterface(s *Stream, val reflect.Value) --Agzs
	if decErr, ok := err.(*decodeError); ok && len(decErr.ctx) > 0 {
		// add decode target type to error so context has more meaning
		log.Info("stream.Decode() decErr") //=>test. --Agzs
		decErr.ctx = append(decErr.ctx, fmt.Sprint("(", rtyp.Elem(), ")"))
	}
	return err
}
```

未重新定义types.PbftMessage前，该部分不报错，其中decoder会调用`decodeInterface(s *Stream, val reflect.Value)`

重新定义修改后，会执行`log.Info("stream.Decode() decErr")`，出现decErr错误。

* 问题原因如下：

在新修改的types.PbftMessage结构体中，将payload换成了preprepare、prepare...等指针，如果要发送的消息是相关类型的消息，就赋值给该成员变量，其他成员变量为nil，（比如要发送preprep，则types.PbftMessage的成员变量PrePrepare指针指向preprep，其他成员变量指针都设置为空）。当时只是为了解决消息发送问题，没想到在这出错了。由于新修改的结构体types.PbftMessage中在使用时含有空指针数据，所以会报此错误。新修改的结构体类型如下：
```go
type pbftMessage struct {
	PrePrepare *PrePrepare //=> payload = 1
	Prepare    *Prepare    //=> payload = 2
	Commit     *Commit     //=> payload = 3
	Checkpoint *Checkpoint //=> payload = 4
	ViewChange *ViewChange //=> payload = 5
	NewView    *NewView    //=> payload = 6
	//FetchBlockMsg *FetchBlockMsg //=> payload = 7
	Sender      uint64 //=>add. --Agzs
	PayloadCode uint64
	Payload     interface{}
}
```

* 解决方法：

重新定义结构体，去除指针定义，采用原先的payload，定义为接口类型：
```go
type pbftMessage struct {
	Sender      uint64 //=>add. --Agzs
	PayloadCode uint64
	Payload     interface{}
}
```问题解决，主节点可以发送消息，其他VP能收到消息，却出现解码错误问题(二）

### 8、解码错误问题(二） payload
主节点可以发送消息，其他VP能收到消息，可以获取到除payload以外的所有数据，唯独无法识别payload的真实类型（比如PrePrepare），报错如下：
```go
panic: interface conversion: interface {} is []interface {}, not *types.PrePrepare
```
* 原因：

types.PbftMessage在p2p传播的时候被转换成inteface{}类型，而payload作为其成员变量也是接口类型，由于interface的类型转换比较混乱，参考[go：interface{}、断言与类型转换](http://www.cnblogs.com/xiaopipi/p/4889212.html)，RLP编码传参的类型是interface，初步猜想RLP可以编码，但是解码的时候，无法读取interface类型的数据。

ethereum中的block定义也有interface{}成员变量：`ReceivedFrom interface{}`，但是该变量并未通过编解码，而是通过`request.Block.ReceivedFrom = p`，其中p是handleMsg(p *peer)中的参数。

* 解决方法：

将`types.PbftMessage`中的payload在p2p发送之前读取出来，使用各自的msg.code，分类发送；接收端，分类回收，最后组装成`types.PbftMessage`，然后进行事件处理，具体修改[修改文件汇总11.5](https://github.com/Agzs/geth-pbft-study/wiki/%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%B1%87%E6%80%BB)

### 9、sendViewChange报错
* 提示错误：
```go
panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0xc93636]

goroutine 55 [running]:
github.com/yeongchingtarn/geth-pbft/consensus/pbft.(*pbftCore).sendViewChange(0xc4203d2000, 0x10aafe8, 0x3d)
	/home/zhiguo/go/src/github.com/yeongchingtarn/geth-pbft/consensus/pbft/viewchange.go:185 +0x736
github.com/yeongchingtarn/geth-pbft/consensus/pbft.(*pbftCore).ProcessEvent(0xc4203d2000, 0xf02820, 0x1a13f30, 0xc4216b9a60, 0x1)
	/home/zhiguo/go/src/github.com/yeongchingtarn/geth-pbft/consensus/pbft/pbft-core.go:373 +0xf37
```

* 原因：其他signer未启动miner.start()，导致signer和signFn没有初始化赋值：

```go
func (s *Ethereum) StartMining(local bool) error {
	eb, err := s.Etherbase()
	...
	//=>add PBFT StratMining. start --Agzs
	if pbft, ok := s.engine.(*pbft.PBFT); ok {
		wallet, err := s.accountManager.Find(accounts.Account{Address: eb})
		if wallet == nil || err != nil {
			log.Error("Etherbase account unavailable locally", "err", err)
			return fmt.Errorf("singer missing: %v", err)
		}
		pbft.Authorize(eb, wallet.SignHash)
	}
	//=>add PBFT StratMining. end --Agzs

	...
	go s.miner.Start(eb)
	return nil
}
```
* 解决方法：

其他signer节点运行miner.start()

### 10、其他节点处理消息后，只向主节点回复消息，没有向p2p其他的peer广播

主节点可以向其他所有peer广播，signer1:
```go
INFO [11-04|23:01:43] peer broadcast msg                       peer=4a3de4861cca1453 send msg's hash:=cf1a9b…818e4d
INFO [11-04|23:01:43] peer.SendMsg() start                     pbftMessageType=*types.PrePrepare
INFO [11-04|23:01:43] p2p sends message!!! before writeMsg()   msgsize=650 msgcode=17
INFO [11-04|23:01:43] WriteMsg()                               msg.Code=17 offset=16

INFO [11-04|23:01:43] peer broadcast msg                       peer=032d933d9b02b13a send msg's hash:=cf1a9b…818e4d
INFO [11-04|23:01:43] peer.SendMsg() start                     pbftMessageType=*types.PrePrepare
INFO [11-04|23:01:43] p2p sends message!!! before writeMsg()   msgsize=650 msgcode=17
INFO [11-04|23:01:43] WriteMsg()                               msg.Code=17 offset=16

INFO [11-04|23:01:43] peer broadcast msg                       peer=906b7ebc5c0f0f5e send msg's hash:=cf1a9b…818e4d
INFO [11-04|23:01:43] peer.SendMsg() start                     pbftMessageType=*types.PrePrepare
INFO [11-04|23:01:43] p2p sends message!!! before writeMsg()   msgsize=650 msgcode=17
INFO [11-04|23:01:43] WriteMsg()                               msg.Code=17 offset=16
INFO [11-04|23:01:43] pm.BroadcastMsg() end------------ 
```
而其他signer只能向主节点广播，比如signer2节点：
```go
INFO [11-04|23:01:43] handleMsg() ---PrePrepareMsg----------- 
INFO [11-04|23:01:43] send preprepare_message to pm.pbftmanager.Queue() 
2017/11/04 23:01:43 Replica 1 processing event
2017/11/04 23:01:43 Replica 1 received incoming message from 0
INFO [11-04|23:01:43] recvMsg() test                           sendID=0 code=1 payload=*types.PrePrepare
2017/11/04 23:01:43 Replica 1 processing event
2017/11/04 23:01:43 Replica 1 received pre-prepare from replica 0 for view=0/seqNo=9
INFO [11-04|23:01:43] Replica storing block in outstanding block store Replica(PeerID)=1 hash=738efc…270394

2017/11/04 23:01:43 Backup 1 broadcasting prepare for view=0/seqNo=9
2017/11/04 23:01:43 Replica 1 received prepare from replica 1 for view=0/seqNo=9
2017/11/04 23:01:43 Replica 1 prepare count for view=0/seqNo=9: 1
2017/11/04 23:01:43 Replica 1 prepare count for view=0/seqNo=9: 1
2017/11/04 23:01:43 send msg to commChan!

INFO [11-04|23:01:43] pm.BroadcastMsg() start------------ 
INFO [11-04|23:01:43] peer broadcast msg                       peer=e29caed3b331495a send msg's hash:=a912a3…0f22d3
INFO [11-04|23:01:43] peer.SendMsg() start                     pbftMessageType=*types.Prepare
INFO [11-04|23:01:43] p2p sends message!!! before writeMsg()   msgsize=40  msgcode=18
INFO [11-04|23:01:43] WriteMsg()                               msg.Code=18 offset=16
INFO [11-04|23:01:43] pm.BroadcastMsg() end------------ 
```
主节点(signer1)可以收到其他三个signer的prepare，然后发出commit,其他signer能收到主节点的commit，但是signer互相之间却收不到各自的prepare,导致其他signer无法发送自己的commit，会进一步触发viewchange。

* 问题原因:

其他signer都只是和signer1建立了联系，但是互相之间没有建立联系.


* 解决方法：

使用admin.addPeer("")进行添加，比如有四个signer，分别为signer1、signer2、signer3、signer4，signer1为主节点：

需要在`signer2`、`signer3`、`signer4`终端都运行`admin.addPeer("encode://...signer1_encode...")`

需要在`signer3`、`signer4`终端都运行`admin.addPeer("encode://...signer2_encode...")`

需要在`signer4`终端都运行`admin.addPeer("encode://...signer3_encode...")`

修改上述错误后，节点间都能收到commit，但是在recvCommit()函数内存在错误。。。

### 11、recvCommit()问题

在pbft-core.go中，recvCommit()函数中，只能打印出`recvCommit(1) --executeOutstanding()`
```go
instance.executeOutstanding()                      ////xiaobei
		log.Info("recvCommit(1) --executeOutstanding()")   //=>test. --Agzs
		instance.helper.manager.Queue() <- execDoneEvent{} ////xiaobei
		log.Info("recvCommit(2) --send execDoneEvent")     //=>test. --Agzs
		instance.finishedChan <- struct{}{}                /// inform PBFT consensus is reached.  --Zhiguo
		log.Info("recvCommit(3) --finished")               //=>test. --Agzs

```

* 原因

`instance.helper.manager.Queue() <- execDoneEvent{}`语句向Queue()中发送事件，该函数返回值为channel类型，一次只能存储一个事件。运行过程中可能存在拥挤或抢占，有的事件可能无法挤进该channel，或者发送到channel中，刚开始要处理，又被其他事件抢占了。（注：以上只是猜想，由于goroutine的存在，情况不好判定）

* 解决方法

将`execDoneEvent{}`触发的操作，移到此处，在processEvent()中的注释掉：
```go
                instance.executeOutstanding()                    ////xiaobei
		log.Info("recvCommit(1) --executeOutstanding()") //=>test. --Agzs
		//============================
		//instance.helper.manager.Queue() <- execDoneEvent{} ////xiaobei
		instance.execDoneSync()
		log.Info("execDoneSync() end") //=>test. --Agzs
		if instance.skipInProgress {
			instance.retryStateTransfer(nil)
			log.Info("retryStateTransfer() end") //=>test. --Agzs
		}
		//=========================
		log.Info("recvCommit(2) --send execDoneEvent") //=>test. --Agzs
		instance.finishedChan <- struct{}{}            /// inform PBFT consensus is reached.  --Zhiguo
		log.Info("recvCommit(3) --finished")           //=>test. --Agzs
```
问题解决，并且signer1成功挖出区块1：
```go
INFO [11-05|20:53:51] recvCommit(1) --executeOutstanding() 
INFO [11-05|20:53:51] execDoneSync() 
2017/11/05 20:53:51 Replica 0 had execDoneSync called, flagging ourselves as out of date
2017/11/05 20:53:51 Replica 0 attempting to executeOutstanding
2017/11/05 20:53:51 Replica 0 certstore map[{v:0 n:3}:0xc436d02720]
INFO [11-05|20:53:51] execDoneSync() end 
2017/11/05 20:53:51 Replica 0 has no targets to attempt state transfer to, delaying
INFO [11-05|20:53:51] retryStateTransfer() end 
INFO [11-05|20:53:51] recvCommit(2) --send execDoneEvent 
INFO [11-05|20:53:51] recvCommit(3) --finished 
INFO [11-05|20:53:51] Successfully sealed new block            number=1 hash=a7c286…300942

...
INFO [11-05|20:53:51] 🔨 mined potential block                  number=1 hash=a7c286…300942

...
INFO [11-05|20:53:51] Commit new mining work                   number=2 txs=0 uncles=0 elapsed=437.671µs
```
但是，其他signer却提示“Discarded bad propagated block”，见问题9。

### 12、rocksDB错误(强制退出造成的问题）

```go
panic: Error opening DB: IO error: lock /home/zhiguo/hyperledgerRocksDB/signer1/db/LOCK: Resource temporarily unavailable
```
* 原因

终端运行时，没有正常退出，导致rocksDB关闭的”善后“工作没有进行。

强制退出：
```go
> exit
INFO [11-05|11:30:03] IPC endpoint closed: /home/zhiguo/pbft/signer2/data/geth.ipc 
INFO [11-05|11:30:03] Blockchain manager stopped 
INFO [11-05|11:30:03] Stopping Ethereum protocol 
INFO [11-05|11:30:03] Read the next message from the remote peer in pm.handleMsg() 
INFO [11-05|11:30:03] Read the next message from the remote peer in pm.handleMsg() returns error 
INFO [11-05|11:30:03] Read the next message from the remote peer in pm.handleMsg() 
INFO [11-05|11:30:03] Read the next message from the remote peer in pm.handleMsg() returns error 
^C
INFO [11-05|11:30:41] Got interrupt, shutting down... 
^Z
[1]+  Stopped                 geth --datadir ./data --networkid 55661 --pbftid 1 --port 2003 --unlock c28e9d79dfa4a291cbf7422f4ba82fa59e710bc4 console

```

正常退出：
```go
> exit
INFO [11-05|11:21:42] IPC endpoint closed: /home/zhiguo/pbft/signer2/data/geth.ipc 
INFO [11-05|11:21:42] Blockchain manager stopped 
INFO [11-05|11:21:42] Stopping Ethereum protocol 
INFO [11-05|11:21:42] Ethereum protocol stopped 
INFO [11-05|11:21:42] Transaction pool stopped 
INFO [11-05|11:21:42] Database closed                          database=/home/zhiguo/pbft/signer2/data/geth/chaindata
2017/11/05 11:21:42 RocksDB closed!
```
比较发现，`IPC`和`Blockchain manager`均正常关闭，`Ethereum protocol`、`Transaction pool`、`Database`均未正常关闭。

* 解决方法

直接杀死进程：

在终端运行`ps`指令：
```go
ethtest@ethtest:~/pbft$ ps
  PID TTY          TIME CMD
21553 pts/23   00:00:00 bash
23747 pts/23   00:00:01 geth
23908 pts/23   00:00:00 ps
```
强制杀死进程23747：
```go
ethtest@ethtest:~/pbft$ sudo kill -9 23747
[1]+  Killed                  geth --datadir pbft/signer1/data --networkid 55661 --port 2000  (wd: ~)
(wd now: ~/pbft)

```
以下是之前的解决方法，比较笨，可直接跳过到下一个问题。

~目前没有有效的解决方法，只能找到相关db文件夹，删除之。~

删除之后，rocksDB没有问题了，levelDB又出现问题了

```go
INFO [11-05|16:29:09] Starting peer-to-peer node               instance=Geth/v1.6.7-stable/linux-amd64/go1.8.3
2017/11/05 16:29:09 Is db path [/home/zhiguo/hyperledgerRocksDB/signer3/db] empty [false]
2017/11/05 16:29:09 Setting rocksdb maxLogFileSize to 10485760
2017/11/05 16:29:09 Setting rocksdb keepLogFileNum to 10
2017/11/05 16:29:09 Setting rocks db InfoLogLevel to 2
INFO [11-05|16:29:09] Allocated cache and file handles         database=/home/zhiguo/pbft/signer2/data/geth/chaindata cache=128 handles=1024
Fatal: Error starting protocol stack: resource temporarily unavailable
```
继续将相关文件删除， 又提示：
```go
INFO [11-05|16:34:50] init protocol manager and commChan in NewProtocolManager()! replica=3
INFO [11-05|16:34:50] Starting P2P networking 
Fatal: Error starting protocol stack: listen udp :2005: bind: address already in use
```
最终，只能将signer目录下的所有文件删除，重新创建账户，初始化的创世区块。。。。。

此外， `pbft.json`需要进行修改，（当然也可以删除后重新生成），如果进行修改的话，需要修改两部分：

1）授权节点部分
```go
"extraData": "0x0000000000000000000000000000000000000000000000000000000000000000
557afdbcc81c0199305ebbc61580eb0b17be7fdb
575b73df85e22751c143e839ac90c04796463b2f
c28e9d79dfa4a291cbf7422f4ba82fa59e710bc4
73ab48254894b1b645e37bbeec2c55d6c5bd6b04 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
```
这是四个授权的账户，需要换成新创建的账户。(为了观察方便，我对四个账户添加了换行，原文件中四个账户的地址都是连载一起的)

2）预设账户余额部分
```go
 "575b73df85e22751c143e839ac90c04796463b2f": {
      "balance": "0x200000000000000000000000000000000000000000000000000000000000000"
    },
 "c4006961eda5b91c38fd93ee6021679f25b97410": {
      "balance": "0x200000000000000000000000000000000000000000000000000000000000000"
    }
```
其中575为signer1的账户地址，c40为node1地址.

### 13、无法正常退出
```go
> exit
INFO [11-05|17:39:23] IPC endpoint closed: /home/zhiguo/pbft/signer1/data/geth.ipc 
INFO [11-05|17:39:23] Blockchain manager stopped 
INFO [11-05|17:39:23] Stopping Ethereum protocol 
INFO [11-05|17:39:23] Read the next message from the remote peer in pm.handleMsg() 
INFO [11-05|17:39:23] Read the next message from the remote peer in pm.handleMsg() returns error 
INFO [11-05|17:39:23] Read the next message from the remote peer in pm.handleMsg() 
INFO [11-05|17:39:23] Read the next message from the remote peer in pm.handleMsg() returns error 
WARN [11-05|17:45:09] System clock seems off by -12.297202182s, which can prevent network connectivity 
WARN [11-05|17:45:09] Please enable network time synchronisation in system settings. 
WARN [11-05|18:05:52] System clock seems off by -12.302529327s, which can prevent network connectivity 
WARN [11-05|18:05:52] Please enable network time synchronisation in system settings. 
WARN [11-05|18:17:04] System clock seems off by -12.301364649s, which can prevent network connectivity 
WARN [11-05|18:17:04] Please enable network time synchronisation in system settings. 
WARN [11-05|18:39:11] System clock seems off by -12.291644646s, which can prevent network connectivity 
WARN [11-05|18:39:11] Please enable network time synchronisation in system settings. 
WARN [11-05|18:54:23] System clock seems off by -12.275869174s, which can prevent network connectivity 
WARN [11-05|18:54:23] Please enable network time synchronisation in system settings. 
WARN [11-05|19:05:01] System clock seems off by -12.28059504s, which can prevent network connectivity 
WARN [11-05|19:05:01] Please enable network time synchronisation in system settings. 

```
一直停顿在这。。。

* 原因未知，目前暂时未重新遇到，一般停顿20s左右就正常退出了。
* 解决方法

法1：连续按10次 `ctrl + C`,报错退出。虽然是笨方法，但是重新运行geth console不会遇到**错误(12)**

法2：强制退出，类似问题7的解决方法

### 14、同步区块模式问题

signer1成功挖出区块1：
```go
INFO [11-05|20:53:51] recvCommit(1) --executeOutstanding() 
INFO [11-05|20:53:51] execDoneSync() 
2017/11/05 20:53:51 Replica 0 had execDoneSync called, flagging ourselves as out of date
2017/11/05 20:53:51 Replica 0 attempting to executeOutstanding
2017/11/05 20:53:51 Replica 0 certstore map[{v:0 n:3}:0xc436d02720]
INFO [11-05|20:53:51] execDoneSync() end 
2017/11/05 20:53:51 Replica 0 has no targets to attempt state transfer to, delaying
INFO [11-05|20:53:51] retryStateTransfer() end 
INFO [11-05|20:53:51] recvCommit(2) --send execDoneEvent 
INFO [11-05|20:53:51] recvCommit(3) --finished 
INFO [11-05|20:53:51] Successfully sealed new block            number=1 hash=a7c286…300942

...
INFO [11-05|20:53:51] 🔨 mined potential block                  number=1 hash=a7c286…300942

...
INFO [11-05|20:53:51] Commit new mining work                   number=2 txs=0 uncles=0 elapsed=437.671µs
```
但是，其他signer却提示：
```go
INFO [11-05|20:53:51] recvCommit(1) --executeOutstanding() 
INFO [11-05|20:53:51] execDoneSync() 
2017/11/05 20:53:51 Replica 1 had execDoneSync called, flagging ourselves as out of date
2017/11/05 20:53:51 Replica 1 attempting to executeOutstanding
2017/11/05 20:53:51 Replica 1 certstore map[{v:0 n:3}:0xc4368ab860]
INFO [11-05|20:53:51] execDoneSync() end 
2017/11/05 20:53:51 Stopping timer
INFO [11-05|20:53:51] send commit_message to pm.pbftmanager.Queue() 
2017/11/05 20:53:51 Replica 1 has no targets to attempt state transfer to, delaying
INFO [11-05|20:53:51] retryStateTransfer() end 
INFO [11-05|20:53:51] recvCommit(2) --send execDoneEvent 
INFO [11-05|20:53:51] Read the next message from the remote peer in pm.handleMsg() 
INFO [11-05|20:53:51] handleMsg() ---NewBlockMsg----------- 
INFO [11-05|20:53:51] Read the next message from the remote peer in pm.handleMsg() 
INFO [11-05|20:53:51] handleMsg() ---NewBlockHashesMsg----------- 
WARN [11-05|20:53:51] Discarded bad propagated block           number=1 hash=a7c286…300942
INFO [11-05|20:53:52] Read the next message from the remote peer in pm.handleMsg() 
INFO [11-05|20:53:52] handleMsg() ---NewBlockMsg----------- 
WARN [11-05|20:53:52] Discarded bad propagated block           number=1 hash=a7c286…300942
```

* 原因

```go
func NewProtocolManager(config *params.ChainConfig, mode downloader.SyncMode, networkId uint64, maxPeers int, mux *event.TypeMux, txpool txPool, engine consensus.Engine, blockchain *core.BlockChain, chaindb ethdb.Database) (*ProtocolManager, error) {
	// Create the protocol manager with the base fields
	manager := &ProtocolManager{
		...
	}

	...
	// Figure out whether to allow fast sync or not
	if mode == downloader.FastSync && blockchain.CurrentBlock().NumberU64() > 0 {
		log.Warn("Blockchain not empty, fast sync disabled")
		mode = downloader.FullSync
	}
	if mode == downloader.FastSync {
		manager.fastSync = uint32(1)
	}

	...
	inserter := func(blocks types.Blocks) (int, error) {
		// If fast sync is running, deny importing weird blocks
		if atomic.LoadUint32(&manager.fastSync) == 1 {
			log.Warn("Discarded bad propagated block", "number", blocks[0].Number(), "hash", blocks[0].Hash())
			return 0, nil
		}
		atomic.StoreUint32(&manager.acceptTxs, 1) // Mark initial sync done on any fetcher import
		return manager.blockchain.InsertChain(blocks)
	}
	manager.fetcher = fetcher.New(blockchain.GetBlockByHash, validator, manager.BroadcastBlock, heighter, inserter, manager.removePeer)

	return manager, nil
}
```
manager.fastSync被设置为1了，这是ethereum的默认配置。经查找代码发现，只有执行`inserter`函数才会提示`Discarded bad propagated block`，而`inserter`函数被赋值给`Fetcher.insertChain`，最终在insert()中被调用：
```go
func (f *Fetcher) insert(peer string, block *types.Block) {
	hash := block.Hash()

	// Run the import on a new thread
	log.Debug("Importing propagated block", "peer", peer, "number", block.Number(), "hash", hash)
	go func() {
		...
		if _, err := f.insertChain(types.Blocks{block}); err != nil {
			log.Debug("Propagated block import failed", "peer", peer, "number", block.Number(), "hash", hash, "err", err)
			return
		}
		// If import succeeded, broadcast the block
		propAnnounceOutTimer.UpdateSince(block.ReceivedAt)
		go f.broadcastBlock(block, false)

		// Invoke the testing hook if needed
		if f.importedHook != nil {
			f.importedHook(block)
		}
	}()
}
```

测试clique的时候，遇到同样的问题，具体原因未知，但是在clique中任意两个点运行`admin.addPeer()`，两两互联后，该问题消失。

后继续查找原因，发现`pbft`中使用了clique中的`snap.Recents`，该变量用于标记最近签名的`signer`，如果该`signer`近期签过名，后期便不能再次签名，会返回`errUnauthorized`，主要有以下三个地方存在这个问题（添加注释部分）：
```go
func (c *PBFT) verifySeal(chain consensus.ChainReader, header *types.Header, parents []*types.Header) error {
	...
	// for seen, recent := range snap.Recents {
	// 	if recent == signer {
	// 		// Signer is among recents, only fail if the current block doesn't shift it out
	// 		if limit := uint64(len(snap.Signers)/2 + 1); seen > number-limit {
	// 			return errUnauthorized
	// 		}
	// 	}
	// }
	// Ensure that the difficulty corresponds to the turn-ness of the signer
	inturn := snap.inturn(header.Number.Uint64(), signer)
	if inturn && header.Difficulty.Cmp(diffInTurn) != 0 {
		return errInvalidDifficulty
	}
	if !inturn && header.Difficulty.Cmp(diffNoTurn) != 0 {
		return errInvalidDifficulty
	}
	return nil
}
```
```go
func (c *PBFT) Seal(chain consensus.ChainReader, block *types.Block, stop <-chan struct{}) (*types.Block, error) {
	...
	//=> --Agzs
	// // If we're amongst the recent signers, wait for the next block
	// for seen, recent := range snap.Recents {
	// 	if recent == signer {
	// 		// Signer is among recents, only wait if the current block doesn't shift it out
	// 		if limit := uint64(len(snap.Signers)/2 + 1); number < limit || seen > number-limit {
	// 			log.Info("Signed recently, must wait for others")
	// 			<-stop
	// 			return nil, nil
	// 		}
	// 	}
	// }

	...
	// Sign all the things!
	sighash, err := signFn(accounts.Account{Address: signer}, sigHash(header, nil).Bytes()) //=> TODO. --Agzs
	...
	newBlock := block.WithSeal(header)
	
	c.pbft.recvRequestBlock(newBlock) 

	/// TODO: wait until the commit messages are received by 2/3 PBFT nodes, then return the block --Zhiguo
	select {
	case <-stop:
		log.Info("Stop PBFT algorithm!")
		return nil, nil
	case <-c.finishedChan:
		//c.pbft.lastExec = newBlock.Header().Number.Uint64() //=>TODO. lastExec. --Agzs
		return newBlock, nil
	}

	///        return nil, nil

}
```
```go
func (s *Snapshot) apply(headers []*types.Header) (*Snapshot, error) {
	...
		// for _, recent := range snap.Recents {
		// 	if recent == signer {
		// 		return nil, errUnauthorized
		// 	}
		// }
	...
}

```
由于返回了`errUnauthorized`，其后语句无法正常进行，所以会造成该错误。

* 解决方法

注释掉上述三个地方的`snap.Recents`中返回`errUnauthorized`的for循环，如上所示。

解决掉上述问题后，signer1可以连续挖块，其他signer也可以import这些区块，包括加入通过addPeer()添加的node也可以import。

**注意：**

建议运行前删除存储`rocksDB`的`db`文件夹，因为运行测试的过程中必定存在错误，而一些错误的`preprepare`等其他消息将会保存到`pset`和`qset`，然后进一步保存到`rocksDB`，重新启动后，这些数据都会被重新读取，导致一些`seqNo`出现错误，程序无法正常运行，一定要注意这一点！！！！！！

### 15、权限问题

在**问题14没解决**的基础上，猜想问题9解决后，该问题应该会解决。

关闭各终端，然后重新运行geth，又遇到新问题：

signer1报错：
```go
INFO [11-06|10:57:37] Successfully sealed new block            number=2 hash=205067…39e5d8
INFO [11-06|10:57:37] 🔨 mined potential block                  number=2 hash=205067…39e5d8
ERROR[11-06|10:57:37] Failed to prepare header for mining      err=unauthorized
```
signer2报错，其他signer类似：
```go
INFO [11-06|10:57:37] Imported new chain segment               blocks=1 txs=0 mgas=0.000 elapsed=220.297µs mgasps=0.000 number=2 hash=205067…39e5d8
ERROR[11-06|10:57:37] Failed to prepare header for mining      err=unauthorized
```
如果正常的话，signer2应该import的blocks的数目为2，并且signer1不会出现未授权情况。

**测试clique正常运行情况**：

signer1运行结果：
```go
> miner.start()
INFO [11-06|11:10:10] Transaction pool price threshold updated price=18000000000
INFO [11-06|11:10:10] Starting mining operation 
null
> INFO [11-06|11:10:10] Commit new mining work                   number=22 txs=0 uncles=0 elapsed=113.333µs
INFO [11-06|11:10:10] Successfully sealed new block            number=22 hash=af7e9b…d34f0c
INFO [11-06|11:10:10] 🔨 mined potential block                  number=22 hash=af7e9b…d34f0c
INFO [11-06|11:10:10] Commit new mining work                   number=23 txs=0 uncles=0 elapsed=408.973µs
> admin.addPeer("enode://996058eac555decf228b31699553d28fb1f65fb116f6d98b18b9f42d4d65498a4f9db808ace34211e3b7fad627f028f6c7fdd39b745aa3cdca2ca367ac51b362@127.0.0.1:2000")
INFO [11-06|11:10:20] Successfully sealed new block            number=23 hash=0c3286…2bd8eb
INFO [11-06|11:10:20] 🔨 mined potential block                  number=23 hash=0c3286…2bd8eb
INFO [11-06|11:10:20] Commit new mining work                   number=24 txs=0 uncles=0 elapsed=391.673µs
INFO [11-06|11:10:30] Successfully sealed new block            number=24 hash=383202…0d2002
INFO [11-06|11:10:30] 🔨 mined potential block                  number=24 hash=383202…0d2002
INFO [11-06|11:10:30] Commit new mining work                   number=25 txs=0 uncles=0 elapsed=379.078µs

true
```
node1运行结果：
```go
INFO [11-06|11:10:38] Imported new chain segment               blocks=4 txs=0 mgas=0.000 elapsed=1.844ms mgasps=0.000 number=24 hash=383202…0d2002 ignored=4
INFO [11-06|11:10:40] Read the next message from the remote peer in pm.handleMsg() 
INFO [11-06|11:10:40] handleMsg() ---NewBlockMsg----------- 
INFO [11-06|11:10:40] Read the next message from the remote peer in pm.handleMsg() 
INFO [11-06|11:10:40] handleMsg() ---NewBlockHashesMsg----------- 
INFO [11-06|11:10:40] Imported new chain segment               blocks=1 txs=0 mgas=0.000 elapsed=292.206µs mgasps=0.000 number=25 hash=c0e8f4…e9449d

```

* 解决方法
问题14解决后，该问题不存在。。。。。。。

